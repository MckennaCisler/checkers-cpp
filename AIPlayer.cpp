#include "AIPlayer.h"

#include "Board.h"
#include "Piece.h"
#include "Move.h"
#include "Typedefs.h"

#include <unordered_map>
#include <vector>
#include <cstdlib>

/**
 * Gets a move, generated by the AI.
 * @param board The board to apply the move to
 * @return Returns the board, modified according to the computer's move
 */
void AIPlayer::getMove(Board& board)
{
	using namespace std;
	typedef unordered_map<Piece*, moves_t> move_choices_t;
	typedef unordered_map<move_ptr_t, Piece*> best_moves_t; 

    // create list of possible pieces and their moves
    move_choices_t possibleChoices;
    
    // loop over all peices on the board until we get one that has some moves to work with
    // (we should get the best ones last by starting at the top - and this will come out best if we have repeats later in this function)
    for (int x = 0; x < Board::SIZE; x++)
    {
        for (int y = 0; y < Board::SIZE; y++)
        {
            // if there's a piece here the same color as ours...
            Piece* piece = board.getValueAt(x, y);
            if (piece != nullptr && piece->isWhite == this->isWhite)
            {
                // ...find moves its
                moves_t possibleMoves = piece->getAllPossibleMoves(board);
                
                // and add them with the piece to our list if there is at least one
                if (!possibleMoves.empty())
                    possibleChoices[piece] = possibleMoves;
            }
        }
    }
           
    // record furthest back and furthest forward piece to alternate between 
    // (just assign the first one in the key list for now)
    Piece* furthestBackwardPiece = possibleChoices.begin()->first;
    Piece* furthestForwardPiece =  possibleChoices.begin()->first;
    
    // iterate over our collected possibilites, looking for the best canidate 
    // (based on this answer: http://stackoverflow.com/a/110255/3155372)
    best_moves_t bestMovesPerPiece;
    for (auto it : possibleChoices)
    {
    	Piece* piece = it.first;
    	
        // check if this piece is furthest back or forward (out of ones with moves)
        int thisPieceY = piece->getCoordinates()[1];
        if (thisPieceY > furthestForwardPiece->getCoordinates()[1])
        {
            // things are switched if we're the other color (furthest "forward" is furthest back)
            if (isWhite)
                furthestForwardPiece = piece;
            else
                furthestBackwardPiece = piece;
        }
        else if (thisPieceY < furthestBackwardPiece->getCoordinates()[1])
        {
            // things are switched if we're the other color (furthest "forward" is furthest back)
            if (isWhite)
                furthestBackwardPiece = piece;
            else
                furthestForwardPiece = piece;
        }
        
        // for each list of possible moves, iterate over all of them and record their jump numbers
        moves_t possibleMoves = possibleChoices[piece];
        move_ptr_t maxJumpMove = possibleMoves[0]; // just use first for now
        int maxJumpMoveLength = 0;
        for (unsigned int i = 0; i < possibleMoves.size(); i++)
        {
            // get the jump length by the number of pieces jumped (ignore if this isn't a jump move)
            vector<Piece*> jumpedPieces = possibleMoves[i]->getJumpedPieces(board);
            if (!jumpedPieces.empty())
            {
                int jumpLength = jumpedPieces.size();
                
                // if it's the best so far, make it so (we are assuming the best are at the end, so drift that way by replacing similar ones as we go along)
                if (jumpLength >= maxJumpMoveLength)
                {
                    maxJumpMoveLength = jumpLength;
                    maxJumpMove = possibleMoves[i];
                }
            }
        }
        
        // add this best move to our array for the pieces (the piece is a property of the move becasue we focus on the moves)
        bestMovesPerPiece[maxJumpMove] = piece;
    }
    
    // iterate over our best possible pieces and moves, and find the best
    move_ptr_t absoluteBestMove = bestMovesPerPiece.begin()->first; // use first key for now
    int absoluteBestMoveJumpLength = 0;
    for (auto it : bestMovesPerPiece)
    {
    	move_ptr_t move = it.first;
    
        // get the length of this piece's best move's jump (it would be better to calculate this automatically with each new move, but its okay to repeat above)
        vector<Piece*> jumpedPieces = move->getJumpedPieces(board);
        
        // we're only looking at jumping moves here
        if (!jumpedPieces.empty())
        {
            int thisBestMoveJumpLength = jumpedPieces.size();
        
            // if this one is best now, make it so
            if (thisBestMoveJumpLength >= absoluteBestMoveJumpLength)
            {
                absoluteBestMoveJumpLength = thisBestMoveJumpLength;
                absoluteBestMove = move;
            }
        }
    }
    
    // if we have a jump to do, do it...
    if (absoluteBestMoveJumpLength > 0)
    {
        board.applyMoveToBoard(absoluteBestMove, bestMovesPerPiece[absoluteBestMove]);
    }
    else // ...otherwise, choose at 50-50 random either the furthest forward or furthest back movable piece (to balance agressiveness)
    {
        int randomNum = rand() & 100;
        if (randomNum >= 50)
        {
        	// get the best move of the piece we want (the keys are the moves)
            board.applyMoveToBoard(getKeyByValue(bestMovesPerPiece, furthestBackwardPiece), furthestBackwardPiece);
        }
        else
        {
            board.applyMoveToBoard(getKeyByValue(bestMovesPerPiece, furthestForwardPiece), furthestForwardPiece);
        }  
    }
}
    
/**
 * Returns a key in a hashmap that correpsonds to the given value
 * @param map The map to search in
 * @param value The value to search for
 * @return Returns the key found in the map, may be null if not found
 */
template <class T, class E>
T AIPlayer::getKeyByValue(std::unordered_map<T, E> map, E value) 
{
    for (auto it : map) 
    {
        if (it.second == value)
        {
            return it.first;
        }
    }
    return nullptr;
}
